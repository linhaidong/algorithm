Rabin-Karp(拉宾－卡普)算法
==
# 介绍:
Rabin-Karp算法是一种字符串查找算法，用于查找字符串中是否包含特定的字符．在一般的字符串查找算法中，应该先
对字符串的特性做判断(字符串的长度等)，如果确实符合算法的需要，则调用相应的算法实现．
# 增进点:
1. 用计算字符串的hash值，替换字符串的逐个比较
2. 重复利用hash值的计算结果


# 关键点:
hash函数，可以任意的添加或删除字符
字符集的个数:
字符集的对应
所有的字符串，可以用字符集的最大值的多项式表示

# hash函数原理：
hash 计算函数的特性:<br>数值必须可以表示出字符的前后顺序，而且可以随时去掉某个字符的值，可以随时添加一个新字符的值）
字符集，字符集的总个数
比如我们要在源串 "9876543210520" 中查找 "520"<br>
因为这些字符串中只有数字，所以我们可以使用字符集 {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'} 来表示字符串中的所有元素，并且将各个字符映射到数字 0～9，然后用` M 表示字符集中字符的总个数`，这里是 10，那么我们就可以将搜索词 "520" 转化为下面的数值：

("5"的映射值 * M + "2"的映射值) * M + "0"的映射值 = (5 * 10 + 2) * 10 + 0 = 520
转换为字符串从左到右的遍历：
５:hash 为０，　所以５的hanh值为，５
2: 原始hash为５，　hash = 5*m+2
0: 原始hash为5*m+2, hash = (5*m+2)*m+0
当然，如果“搜索词”很长，那么计算出来的这个数值就会很大，这时我们可以选一个较大的素数对其取模，用取模后的值作为“搜索词”的值。

# 过程分析
1.计算搜索词
分析一下这个数值：520，它可以代表字符串 "520"，其中:
代表字符 "5" 的部分是“ "5"的映射值 * (M 的 n - 1 次方) = 5 * (10 的 2 次方) = 500”
代表字符 "2" 的部分是“ "2"的映射值 * (M 的 n - 2 次方) = 2 * (10 的 1 次方) = 20”
代表字符 "0" 的部分是“ "0"的映射值 * (M 的 n - 3 次方) = 0 * (10 的 0 次方) = 0”
（n 代表字符串的长度）
我们可以随时减去其中一个字符的值，也可以随时添加一个字符的值。

2.计算原始字符串
“搜索词”计算好了，那么接下来计算“源串”，取“源串”的前 n 个字符（n 为“搜索词”的长度）"987"，按照同样的方法计算其数值：
("9"的映射值 * M + "8"的映射值) * M + "7"的映射值 = (9 * 10 + 8) * 10 + 7 = 987,
然后将该值与搜索词的值进行比较即可。

3.不匹配操作
比较发现 520 与 987 不相等，则说明 "520" 与 "987" 不匹配，则继续向下寻找，这时候该如何做呢？
下一步应该比较 "520" 跟 "876" 了，那么我们如何利用前一步的信息呢？首先我们把 987 减去代表字符 "9" 的部分：
987 - ("9"的映射值 * (M 的 n - 1 次方)) = 987 - (9 * (10 的 2 次方)) = 987 - 900 = 87
然后再乘以 M（这里是 10），再加上 "6" 的映射值，不就成了 876 了么：
87 * M + "6"的映射值 = 87 * 10 + 6 = 876

4.匹配操作
当两个hash值相等的时候，由于采用了取模操作，当两个数值相等时，未必是真正的相等，我们需要进行一次细致的检查（再进行一次朴素的字符串比较）。若不匹配，则可以排除掉。继续下一步。


# 字符串操作实践
如果我们要在 ASCII 字符集范围内查找“搜索词”，由于 ASCII 字符集中有 128 个字符，那么 M 就等于 128，比如我们要在字符串 "abcdefg" 中查找 "cde"，那么我们就可以将搜索词 "cde" 转化为“("c"的码点 * M + "d"的码点) * M + "e"的码点 = (99 * 128 + 100) * 128 + 101 = 1634917”这样一个数值。

　　分析一下这个数值：1634917，它可以代表字符串 "cde"，其中：

代表字符 "c" 的部分是“ "c"的码点 * (M 的 n - 1 次方) = 99 * (128 的 2 次方) = 1622016”
代表字符 "d" 的部分是“ "d"的码点 * (M 的 n - 2 次方) = 100 * (128 的 1 次方) = 12800”
代表字符 "e" 的部分是“ "e"的码点 * (M 的 n - 3 次方) = 101 * (128 的 0 次方) = 101”
（n 代表字符串的长度）
我们可以随时减去其中一个字符的值，也可以随时添加一个字符的值。
“搜索词”计算好了，那么接下来计算“源串”，取“源串”的前 n 个字符（n 为“搜索词”的长度）"abc"，按照同样的方法计算其数值：
("a"的码点 * M + "b"的码点) * M + "c"的码点 = (97 * 128 + 98) * 128 + 99 = 1601891
然后将该值与“搜索词”的值进行比较即可。
比较发现 1634917 与 1601891 不相等，则说明 "cde" 与 "abc" 不匹配，则继续向下寻找，下一步应该比较 "cde" 跟 "bcd" 了，那么我们如何利用前一步的信息呢？首先去掉 "abc" 的数值中代表 a 的部分：
(1601891 - "a"的码点 * (M 的 n - 1 次方)) = (1601891 - 97 * (128 的 2 次方)) = 12643
然后再将结果乘以 M（这里是 128），再加上 "d" 的码点值不就成了 "bcd" 的值了吗：
12643 * 128 + "d"的码点 = 1618304 + 100 = 1618404
这样就可以继续比较 "cde" 和 "bcd" 是否匹配，以此类推。
如果我们要在 Unicode 字符集范围内查找“搜索词”，由于 Unicode 字符集中有 1114112 个字符，那么 M 就等于 1114112，而 Go 语言中使用 16777619 作为 M 的值，16777619 比 1114112 大（更大的 M 值可以容纳更多的字符，这是可以的），而且 16777619 是一个素数。这样就可以使用上面的方法计算 Unicode 字符串的数值了。进而可以对 Unicode 字符串进行比较了。
其实 M 可以理解为进位值，比如 10 进制就是 10，128 进制就是 128，16777619 进制就是 16777619。


# 数学知识
1. 质数分辨定律

简单地说就是：n个不同的质数可以“分辨”的连续整数的个数和他们的乘积相等。
“分辨”就是指这些连续的整数不可能有完全相同的余数序列。
例如：
从2起的连续质数，连续10个质数就可以分辨大约M(10) =2*3*5*7*11*13*17*19*23*29= 6464693230 个数，
已经超过计算机中常用整数（32bit）的表达范围。连续100个质数就可以分辨大约M(100) = 4.711930 乘以10的219次方。



2. 素数定理/质数定理

算术基本定理
任何一个大于1的 自然数N，都可以唯一分解成有限个质数的乘积 N=(P_1^a1)*(P_2^a2)......(P_n^an) , 这里P1....Pn为 质数，其诸方幂 ai 是正整数。
　 
这样的分解称为N 的标准分解式。 
算术基本定理的内容由两部分构成：分解的存在性、分解的唯一性（即若不考虑排列的顺序，正整数分解为素数乘积的方式是唯一的）。

算术基本定理是 初等数论中一个基本的定理，也是许多其他定理的逻辑支撑点和出发点。

此定理可推广至更一般的交换代数和代数数论。高斯证明复整数环Z[i]也有唯一分解定理。它也诱导了诸如唯一分解 整环， 欧几里得整环等等概念。 更一般的还有 戴德金理想分解定理。


# 参考文档
rabin-kranf流程分析
https://www.cnblogs.com/golove/p/3234673.html

Hash树(散列树)和Trie树(字典树、前缀树)
http://blog.51cto.com/tianxingzhe/1720067

hash算法原理
https://www.zhihu.com/question/20507188
